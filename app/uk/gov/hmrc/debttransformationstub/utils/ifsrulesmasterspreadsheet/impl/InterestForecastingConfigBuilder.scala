/*
 * Copyright 2023 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package uk.gov.hmrc.debttransformationstub.utils.ifsrulesmasterspreadsheet.impl

import play.api.libs.json.JsString
import uk.gov.hmrc.debttransformationstub.utils.ifsrulesmasterspreadsheet.impl.IfsRulesMasterData.RegimeUsage

import java.util.Base64

object InterestForecastingConfigBuilder {

  object OutputGenerators {
    def ifsScalaConfig(ifsData: IfsRulesMasterData): Seq[String] = {
      val builtRules = buildRules(ifsData)
      val rules: Seq[String] = {
        val compiledRules = builtRules.zipWithIndex.flatMap { case (rule, idx) =>
          val trailingComma: String = if (idx < builtRules.size - 1) "," else ""

          (rule.scalaConstructorForm + trailingComma).split("\n")
        }

        if (compiledRules.isEmpty) Seq("// No rules were provided.") else compiledRules
      }

      val prefix =
        """/*
          | * Copyright 2025 HM Revenue & Customs
          | *
          | */
          |
          |package uk.gov.hmrc.interestforecasting.rules
          |
          |import uk.gov.hmrc.interestforecasting.models.DebtIdentifier
          |import uk.gov.hmrc.interestforecasting.models.chargeTypes.{ MainTransType, SubTransType }
          |import uk.gov.hmrc.interestforecasting.rules.model.{ DebtRule, DebtRuleProperties, DebtRules, InterestRateRef }
          |
          |/** This entire file is auto-generated by `InterestForecastingRulesGenerator` in the `debt-transformation-stub`. */
          |object BusinessRulesConfiguration {
          |  // This is the business config.
          |  // Declared as a val so that if it throws, it has every opportunity to be noticed.
          |  val businessProvidedRules: DebtRules = DebtRules.createOrThrow(
          |    distinctRules = Vector(""".stripMargin.split("\n")

      val suffix =
        """    )
          |  )
          |
          |}""".stripMargin.split("\n")

      prefix ++ rules.map(line => "      " + line) ++ suffix
    }

    def ifsProductionConfigOverride(ifsData: IfsRulesMasterData): Seq[String] =
      buildRules(ifsData)
        .map(_.rawDslForm)
        .distinct
        .zipWithIndex
        .flatMap { case (rule, index) =>
          List(
            s"# $rule,",
            s"service-config.rules.$index: ${JsString(Base64.getEncoder.encodeToString(rule.getBytes()))}"
          )
        }

    def ifsApplicationConf(ifsData: IfsRulesMasterData): Seq[String] =
      buildRules(ifsData).map(_.rawDslForm).distinct.flatMap { rule =>
        List(
          s"# $rule,",
          s"${JsString(Base64.getEncoder.encodeToString(rule.getBytes()))},"
        )
      }
  }

  private def buildRules(ifsData: IfsRulesMasterData): Seq[InterestRule] = {
    val rules: Seq[InterestRule] =
      (0 until ifsData.maxLength)
        .filter { dataIndex =>
          val regimeUsage: RegimeUsage = ifsData.Interpreted.regimeUsage(dataIndex)

          regimeUsage.isForIfs
        }
        .map { dataIndex =>
          val mainTransString = ifsData.Interpreted.mainTrans(dataIndex)
          val subTransString = ifsData.Interpreted.subTrans(dataIndex)

          val isInterestBearing: Boolean = ifsData.Interpreted.isInterestBearing(dataIndex)
          val intRateId: Int = ifsData.Interpreted.interestBearingId(dataIndex)
          val interestOnlyDebt: Boolean = ifsData.Interpreted.interestOnlyDebt(dataIndex)
          val useChargeReference: Option[Boolean] = ifsData.Interpreted.useChargeReference(dataIndex)

          InterestRule(
            mainTrans = mainTransString,
            subTrans = subTransString,
            isInterestBearing = isInterestBearing,
            interestRateId = intRateId,
            interestOnlyDebt = interestOnlyDebt,
            useChargeReference = useChargeReference
          )
        }
        .sortBy(rule => (rule.mainTrans, rule.subTrans))

    if (rules.map(r => (r.mainTrans, r.subTrans)).distinct.size != rules.size) {
      throw new IllegalArgumentException("Duplicate mainTrans/subTrans combinations are not allowed.")
    }

    rules
  }

  private final case class InterestRule(
    mainTrans: String,
    subTrans: String,
    isInterestBearing: Boolean,
    interestRateId: Int,
    interestOnlyDebt: Boolean,
    useChargeReference: Option[Boolean]
  ) {
    def scalaConstructorForm: String = {
      val interestRateRef: String =
        if (isInterestBearing) s"InterestRateRef.standard" else "InterestRateRef.zero"

      val useChargeReferenceWithComma: String =
        useChargeReference match {
          case Some(useChargeRef) => s", useChargeReference = $useChargeRef"
          case None               => ""
        }

      s"""DebtRule(
         |  DebtIdentifier(MainTransType(${JsString(mainTrans)}), SubTransType(${JsString(subTrans)})),
         |  DebtRuleProperties($interestRateRef, interestOnlyDebt = $interestOnlyDebt$useChargeReferenceWithComma)
         |)""".stripMargin
    }

    def rawDslForm: String = {
      val ifCondition: String = {
        val mainTransClause = s"mainTrans == '${mainTrans: String}'"

        val subTransClause = s"subTrans == '${subTrans: String}'"

        List(mainTransClause, subTransClause).mkString(" AND ")
      }

      val thenClauses: String = {
        val interestRateClause: String = s"intRate = ${interestRateId: Int}"

        val interestOnlyDebtClause: String = s"interestOnlyDebt = ${interestOnlyDebt: Boolean}"

        val useChargeReferenceClause: Option[String] =
          useChargeReference.map(useChargeRef => s"useChargeReference = ${useChargeRef: Boolean}")

        val subClauses: Seq[String] =
          List(Some(interestRateClause), Some(interestOnlyDebtClause), useChargeReferenceClause).flatten

        subClauses.mkString(" AND ")
      }

      s"""IF ${ifCondition: String} -> ${thenClauses: String}"""
    }
  }
}
